{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My Inventory Documentation An Inventory System by Erik (Sandpile) S\u00e4nd. Description My inventory is an Inventory system designed to be easy to use, yet flexible and customizable enough for you to be able to achieve Any inventory look you want ranging from Animal Crossing, to Stardew Valley and Minecraft, all inside the Unity game engine. Every look is achievable using My Inventory! Starting Guide To setup a basic inventory, you first need to configure an InventorySkin scriptableObject to reference. You also need to create a Canvas object in your scene, and add an InventoryImage as a child to the Canvas. fix canvas settings In a new script, add this: public Inventory inventory; public InventorySkin skin; public InventoryImage image; void Awake() { inventory = Inventory.Load(\"player_inventory\", skin); } void Update() { inventory.Draw(image); } Now when you start the unity player, you should see an inventory on the screen. Adding items You will realize that there are no items in your inventory. To add an item to a slot, after loading your inventory you can use inventory.PlaceItem(ItemShelf.Random, 0, 0, 1); This will take a random item from the ItemShelf, and place it in slot(0, 0) with a count of 1.","title":"Home"},{"location":"#my-inventory-documentation","text":"An Inventory System by Erik (Sandpile) S\u00e4nd.","title":"My Inventory Documentation"},{"location":"#description","text":"My inventory is an Inventory system designed to be easy to use, yet flexible and customizable enough for you to be able to achieve Any inventory look you want ranging from Animal Crossing, to Stardew Valley and Minecraft, all inside the Unity game engine. Every look is achievable using My Inventory!","title":"Description"},{"location":"#starting-guide","text":"To setup a basic inventory, you first need to configure an InventorySkin scriptableObject to reference. You also need to create a Canvas object in your scene, and add an InventoryImage as a child to the Canvas. fix canvas settings In a new script, add this: public Inventory inventory; public InventorySkin skin; public InventoryImage image; void Awake() { inventory = Inventory.Load(\"player_inventory\", skin); } void Update() { inventory.Draw(image); } Now when you start the unity player, you should see an inventory on the screen.","title":"Starting Guide"},{"location":"#adding-items","text":"You will realize that there are no items in your inventory. To add an item to a slot, after loading your inventory you can use inventory.PlaceItem(ItemShelf.Random, 0, 0, 1); This will take a random item from the ItemShelf, and place it in slot(0, 0) with a count of 1.","title":"Adding items"},{"location":"about/","text":"Meo manibus Ignavos fit Lorem markdownum pauperque mavult mota, nec tuum inductas dubitare. Qui dominae , necat huic squamae, illic esse signant tendat. Neque nullos pectora. Liberat et vidit mandata iaculum Alexiroe bis egens minimas Nereis in maduere hamis. Cum mollia et Priamum consultus. Visa advertitur spargitque tempora venere fumantiaque doloris flectere at atria posset possedit. Vincas idcirco conveniunt flumine flere, nulli rursusque Martius , pectore. Quoque lucis hic rebus; est meris fuga veluti quo. Iam quod, orbe aequor crescentemque sede quondamque detque . Clarissimus galeae Illis et vitat caelamina, id sic iura sed ferrum. Ipsos vidi dum manu, ac casus in duos, tale iter, Phocus canosque in feruntur, nec in? Nec nimiumque novae, quot Scylla fontem zonarumque ferre, curru suae omnibus; ortu dixi a umbra! Guttura iusta remitti frontes latebris carmina subiectos Cepheaque tamen pars! Fluviis rerum quae relicto pectora erit Dianam nubila a longi scopulo piget perstat exierant aemula, suco ipse? Cultros stantemque praemia addidit: est longum expositum enim subiectis. Deseruere credar illa iunctum domoque Lavini ratibusque hostes. Post aurea formatae iuppiter in, hoc, ego nec perdet. Passosque tempus conubia et humus ambagibus mihi remansit facit, non. Verba persequar etiamnum, quia deme sub est, volui vidi pedibus factum . Cum in hortamine gelidis salices, et auras coercet dictoque habebat dedit eloquioque haec. Terrasque taedia, exire misit patet foro grata largis penetralia recentes ambiguum septem superat sui. Interea utque soror effugit pia otia frustra culta. Regia sistite quibus Cydoneasque, inane; patuisset aere carpitur, frustra quoniam. Per quorum indignata dum patera corna. Omnia adeo Curetas Ira caeli puppim illa contraria illa ingens fallere. Murmure errante investigata bella nobis: urbem quas, Hodites. Duce via quidem iussa igne exstabant inquit Tubere regnata et Taenaria dea nec Cadmi Nec prius inani tanta altera Rate infestus dantibus primos super vires conceptus Invitusque Aetnaea plumis dubitati es decidit sequentem Phoebo conataeque ac desunt alite Veneris et fatebor visu causa dolori locumque per ingens medulla, nec mariti in! Residant malis et removi nec: longa nunc, Palilibus urbe specie, prohibebar, Quae agri. Domus non, umor fontes, alto socerum solum forma filia. Capit superest; velamina et armis minorque, amoris Scyrumve, mirabile muro: petet maris meminisse quotiens.","title":"Meo manibus"},{"location":"about/#meo-manibus","text":"","title":"Meo manibus"},{"location":"about/#ignavos-fit","text":"Lorem markdownum pauperque mavult mota, nec tuum inductas dubitare. Qui dominae , necat huic squamae, illic esse signant tendat. Neque nullos pectora. Liberat et vidit mandata iaculum Alexiroe bis egens minimas Nereis in maduere hamis. Cum mollia et Priamum consultus. Visa advertitur spargitque tempora venere fumantiaque doloris flectere at atria posset possedit. Vincas idcirco conveniunt flumine flere, nulli rursusque Martius , pectore. Quoque lucis hic rebus; est meris fuga veluti quo. Iam quod, orbe aequor crescentemque sede quondamque detque .","title":"Ignavos fit"},{"location":"about/#clarissimus-galeae","text":"Illis et vitat caelamina, id sic iura sed ferrum. Ipsos vidi dum manu, ac casus in duos, tale iter, Phocus canosque in feruntur, nec in? Nec nimiumque novae, quot Scylla fontem zonarumque ferre, curru suae omnibus; ortu dixi a umbra! Guttura iusta remitti frontes latebris carmina subiectos Cepheaque tamen pars! Fluviis rerum quae relicto pectora erit Dianam nubila a longi scopulo piget perstat exierant aemula, suco ipse? Cultros stantemque praemia addidit: est longum expositum enim subiectis. Deseruere credar illa iunctum domoque Lavini ratibusque hostes. Post aurea formatae iuppiter in, hoc, ego nec perdet. Passosque tempus conubia et humus ambagibus mihi remansit facit, non. Verba persequar etiamnum, quia deme sub est, volui vidi pedibus factum . Cum in hortamine gelidis salices, et auras coercet dictoque habebat dedit eloquioque haec. Terrasque taedia, exire misit patet foro grata largis penetralia recentes ambiguum septem superat sui. Interea utque soror effugit pia otia frustra culta. Regia sistite quibus Cydoneasque, inane; patuisset aere carpitur, frustra quoniam. Per quorum indignata dum patera corna.","title":"Clarissimus galeae"},{"location":"about/#omnia-adeo-curetas","text":"Ira caeli puppim illa contraria illa ingens fallere. Murmure errante investigata bella nobis: urbem quas, Hodites. Duce via quidem iussa igne exstabant inquit Tubere regnata et Taenaria dea nec Cadmi Nec prius inani tanta altera Rate infestus dantibus primos super vires conceptus Invitusque Aetnaea plumis dubitati es decidit sequentem Phoebo conataeque ac desunt alite Veneris et fatebor visu causa dolori locumque per ingens medulla, nec mariti in! Residant malis et removi nec: longa nunc, Palilibus urbe specie, prohibebar, Quae agri. Domus non, umor fontes, alto socerum solum forma filia. Capit superest; velamina et armis minorque, amoris Scyrumve, mirabile muro: petet maris meminisse quotiens.","title":"Omnia adeo Curetas"},{"location":"inventory-image/","text":"Inventory Image Description","title":"Inventory Image"},{"location":"inventory-image/#inventory-image","text":"","title":"Inventory Image"},{"location":"inventory-image/#description","text":"","title":"Description"},{"location":"inventory-input/","text":"Inventory Input Description","title":"Inventory Input"},{"location":"inventory-input/#inventory-input","text":"","title":"Inventory Input"},{"location":"inventory-input/#description","text":"","title":"Description"},{"location":"inventory-skin/","text":"Inventory Skin Description An InventorySkin holds all of the data pertaining to the look of your Inventory . All properties on an InventorySkin is local to a certain Inventory, and you can use different InventorySkins for different Inventories. However, some properties are advised to keep same across all of your inventories in a single project. These properties are marked with a * star . InventorySkin properties are not meant to be changed in runtime, but some properties have the ability to, such as material, Z positions, offsets and the different sprites. Properties //The size of your inventory determines the amount of slots it has on the x and y axis. public Vector2 size // Item stacks in a slot can not exceed this value. public int maxItemStack [TODO] // The base material used by the inventory. // Use a Sprites/Default material if you're not sure. public Material material // The method used to render item stack numbers. // Can be Font or Sprite. public InventorySkin.TextType textType [TODO] // The font to use if textType is font. public Font font // Populate this array with number 0-9 if textType is Sprite. public Sprite[] numberSprites // The order of the slots. Can be TopToBottom or BottomToTop. public SlotOrder slotOrder [TODO] // The offset for all of the text instances in pixels. // Default is center of each slot. public Vector2 textPixelOffset // The spacing between numbers, in pixels. public float textSpacing // The number of frames rendered per second. // Keep this number relatively low to improve performance (60 is good). *public int framesPerSecond // Texture subdivision. n means each pixel is subdivided into n*n pixels. // Higher number can produce smoother cursor movement. // Recommened to keep above 1 with lower pixel density sprites to avoid artifacts. *public int textureSubDivision // The sprite used for the background of the inventory. // Sprite pixels Per Unit should be the same as slot Pixels Per Unit. public Sprite background // Sprites used for the different slot states. // Sprite pixels Per Unit should be the side length of the slot. public Sprite slot public Sprite slotHover public Sprite slotLocked // The uniform slot offset relative to the background, in pixels. public Vector2 slotPixelOffset // The uniform spacing between all of the slots, in pixels. public Vector2 slotPixelSpacing // The pixel amount to expand or shrink the area around the slot. // This area checks for cursor position overlap to determine slot state. public float slotSelectPixelExpand // the Z position of different elements of the inventory. // Use renderQueue variables instead to visually order elements. public float slotZ public float itemZ public float textZ public float handZ // The renderQueue of the different elements of the inventory. public int background_renderQueue public int item_renderQueue public int text_renderQueue public int handItem_renderQueue public int handText_renderQueue // The held item offset relative to the cursor position, in pixels. *public Vector2 handPixelOffset // Determines if the held item is snapped to the pixel grid. *public bool snapHandPosition // Holds all the information about individual slot offsets. public InventoryOffsetData offsetData InventoryOffsetData InventoryOffsetData holds all the information about individual slot offsets in an InventorySkin. InventoryOffsetData makes it possible to select several slots, and move them a few pixels in any direction as you see fit. Properties // An array containing all the user defined offsets. public Offset[] offsets Methods // Adds an empty offset to the end of the offsets list. public void AddOffset() // Removes the offset at index from the offsets list. public void RemoveOffset(int index) // Get offset of slot at position, in pixels public Vector2 GetOffset(Vector2 position) InventoryOffsetData.Offset Properties // Positions of Inventory slots affected by this offset. public List<Vector2> positions // Value to offset slots in positions list by, in pixels. public Vector2 value","title":"Inventory Skin"},{"location":"inventory-skin/#inventory-skin","text":"","title":"Inventory Skin"},{"location":"inventory-skin/#description","text":"An InventorySkin holds all of the data pertaining to the look of your Inventory . All properties on an InventorySkin is local to a certain Inventory, and you can use different InventorySkins for different Inventories. However, some properties are advised to keep same across all of your inventories in a single project. These properties are marked with a * star . InventorySkin properties are not meant to be changed in runtime, but some properties have the ability to, such as material, Z positions, offsets and the different sprites.","title":"Description"},{"location":"inventory-skin/#properties","text":"//The size of your inventory determines the amount of slots it has on the x and y axis. public Vector2 size // Item stacks in a slot can not exceed this value. public int maxItemStack [TODO] // The base material used by the inventory. // Use a Sprites/Default material if you're not sure. public Material material // The method used to render item stack numbers. // Can be Font or Sprite. public InventorySkin.TextType textType [TODO] // The font to use if textType is font. public Font font // Populate this array with number 0-9 if textType is Sprite. public Sprite[] numberSprites // The order of the slots. Can be TopToBottom or BottomToTop. public SlotOrder slotOrder [TODO] // The offset for all of the text instances in pixels. // Default is center of each slot. public Vector2 textPixelOffset // The spacing between numbers, in pixels. public float textSpacing // The number of frames rendered per second. // Keep this number relatively low to improve performance (60 is good). *public int framesPerSecond // Texture subdivision. n means each pixel is subdivided into n*n pixels. // Higher number can produce smoother cursor movement. // Recommened to keep above 1 with lower pixel density sprites to avoid artifacts. *public int textureSubDivision // The sprite used for the background of the inventory. // Sprite pixels Per Unit should be the same as slot Pixels Per Unit. public Sprite background // Sprites used for the different slot states. // Sprite pixels Per Unit should be the side length of the slot. public Sprite slot public Sprite slotHover public Sprite slotLocked // The uniform slot offset relative to the background, in pixels. public Vector2 slotPixelOffset // The uniform spacing between all of the slots, in pixels. public Vector2 slotPixelSpacing // The pixel amount to expand or shrink the area around the slot. // This area checks for cursor position overlap to determine slot state. public float slotSelectPixelExpand // the Z position of different elements of the inventory. // Use renderQueue variables instead to visually order elements. public float slotZ public float itemZ public float textZ public float handZ // The renderQueue of the different elements of the inventory. public int background_renderQueue public int item_renderQueue public int text_renderQueue public int handItem_renderQueue public int handText_renderQueue // The held item offset relative to the cursor position, in pixels. *public Vector2 handPixelOffset // Determines if the held item is snapped to the pixel grid. *public bool snapHandPosition // Holds all the information about individual slot offsets. public InventoryOffsetData offsetData","title":"Properties"},{"location":"inventory-skin/#inventoryoffsetdata","text":"InventoryOffsetData holds all the information about individual slot offsets in an InventorySkin. InventoryOffsetData makes it possible to select several slots, and move them a few pixels in any direction as you see fit.","title":"InventoryOffsetData"},{"location":"inventory-skin/#properties_1","text":"// An array containing all the user defined offsets. public Offset[] offsets","title":"Properties"},{"location":"inventory-skin/#methods","text":"// Adds an empty offset to the end of the offsets list. public void AddOffset() // Removes the offset at index from the offsets list. public void RemoveOffset(int index) // Get offset of slot at position, in pixels public Vector2 GetOffset(Vector2 position)","title":"Methods"},{"location":"inventory-skin/#inventoryoffsetdataoffset","text":"","title":"InventoryOffsetData.Offset"},{"location":"inventory-skin/#properties_2","text":"// Positions of Inventory slots affected by this offset. public List<Vector2> positions // Value to offset slots in positions list by, in pixels. public Vector2 value","title":"Properties"},{"location":"inventory/","text":"Inventory Description An Inventory is an object that takes care of drawing an inventory on the screen with help from an InventorySkin and an InventoryImage . The behaviour of an Inventory can be altered using an InventoryInput object. Properties // The unique ID of the inventory. public int ID // The filename of the save file of the inventory slot array. public string FileName // The current InventorySkin used by the Inventory. public InventorySkin skin // The Slot data of the Inventory. public SlotData slotData // A shortcut for slotData.slots[] public Slot[] Slots // Is the inventory being drawn using the inventory.Draw() method? public bool IsDrawing { get; } Static Methods // Loads an inventory from file, or creates a new inventory if no file was found. // Inventory i = Inventory.Load(...); public static Inventory Load(string fileName, InventorySkin skin, bool forceNew = false) // Mark the Inventory system to update the texture size next update. // Usefull after changing aspect ratio. public static void MarkForNewRenderTexture() // Set an InputObject to allow custom behavior written by the user. // See InventoryInput for more information. public static void SetInputObject() // Get the InventoryInput object currently in use. (Null if none) // See InventoryInput for more information. public static InventoryInput GetInputObject() Methods // Reload slotData.slots[] array from last save as FileName. public void Reload() // Save the current slotData.slots[] array as FileName. public void Save() // Save the current slotData.slots[] array as specified fileName. public void Save(string fileName) // Update the Inventory, and draw it on image // according to the inventorySkin.framesPerSecond property. public void Draw(InventoryImage image) // Get Item Index at position (x, y). // Returns -1 if Slot(x, y) doesn't contain an item. public int GetItemIndexAt(int x, int y) // Get Item at position (x, y). // Returns null if position (x, y) does not contain an item. public Item GetItemAt(int x, int y) // Get Item at position. // Returns null if position does not contain an item. public Item GetItemAt(Vector2 position) // Returns true if slot (x, y) contains an item. public bool HasItem(int x, int y) // Returns true if slot at position contains an item. public bool HasItem(Vector2 position) // Returns true if slot at (x, y) contains an item. // itemIndex carries the index of item at (x, y). -1 is no item. public bool HasItem(int x, int y, out int itemIndex) // Returns true if slot at position contains an item. // itemIndex carries the index of item at position. -1 is no item. public bool HasItem(Vector2 position, out int itemIndex) // Returns true if slot at (x, y) contains an item. // item carries the item at (x, y). null if empty. public bool HasItem(int x, int y, out Item item) // Returns true if slot at position contains an item. // item carries the item at position. null if empty. public bool HasItem(Vector2 position, out Item item) // Place held item in the inventory at (x, y). // Swaps items if slot already has item. public void PlaceHeldItem(int x, int y) // Place held item in the inventory at position. // Swaps items if slot already has item. public void PlaceHeldItem(Vector2 position) // Stashes any held item in the first eligible slot. // Returns false if there is no place in the inventory for the Item. // Calls inputObject's OnTossHand(ref Slot hand) method before emptying hand if operation failed. public bool StashHeldItem() // Pick up a certain number of items from slot. // Places/ Swaps item if hand already has item. // If pickUpOneIfSame, picks up one item at (x, y) if hand item is the same as slot item. public void PickUpStack(int x, int y, int count, bool pickUpOneIfSame = false) // Places count items from hand into slot (x, y). // Swaps items if hand item is different from slot item. public void PlaceHeldStack(int x, int y, int count) // Inserts item into slot (x, y) with a stack of count. // Unsafe! (Overrides any item already at x, y) public void InsertItem(Item item, int x, int y, int count = 1) // Places count items in the first available slot. // Adds to stack if possible. // Calls inputObject's OnTossItem(ref Item item) method before emptying hand if operation failed. public bool PlaceItem(Item item, int count = 1) // Place item as specified slot. // Calls inputObject's OnTossItem() method before emptying hand if operation failed. public bool PlaceItem(Item item, int x, int y, int count = 1) Inventory.Renderer Description Static Properties Properties Methods Inventory.MeshData Description Static Properties Properties Methods Inventory.SlotData Description Static Properties Properties Methods Slot Description Properties Methods","title":"Inventory"},{"location":"inventory/#inventory","text":"","title":"Inventory"},{"location":"inventory/#description","text":"An Inventory is an object that takes care of drawing an inventory on the screen with help from an InventorySkin and an InventoryImage . The behaviour of an Inventory can be altered using an InventoryInput object.","title":"Description"},{"location":"inventory/#properties","text":"// The unique ID of the inventory. public int ID // The filename of the save file of the inventory slot array. public string FileName // The current InventorySkin used by the Inventory. public InventorySkin skin // The Slot data of the Inventory. public SlotData slotData // A shortcut for slotData.slots[] public Slot[] Slots // Is the inventory being drawn using the inventory.Draw() method? public bool IsDrawing { get; }","title":"Properties"},{"location":"inventory/#static-methods","text":"// Loads an inventory from file, or creates a new inventory if no file was found. // Inventory i = Inventory.Load(...); public static Inventory Load(string fileName, InventorySkin skin, bool forceNew = false) // Mark the Inventory system to update the texture size next update. // Usefull after changing aspect ratio. public static void MarkForNewRenderTexture() // Set an InputObject to allow custom behavior written by the user. // See InventoryInput for more information. public static void SetInputObject() // Get the InventoryInput object currently in use. (Null if none) // See InventoryInput for more information. public static InventoryInput GetInputObject()","title":"Static Methods"},{"location":"inventory/#methods","text":"// Reload slotData.slots[] array from last save as FileName. public void Reload() // Save the current slotData.slots[] array as FileName. public void Save() // Save the current slotData.slots[] array as specified fileName. public void Save(string fileName) // Update the Inventory, and draw it on image // according to the inventorySkin.framesPerSecond property. public void Draw(InventoryImage image) // Get Item Index at position (x, y). // Returns -1 if Slot(x, y) doesn't contain an item. public int GetItemIndexAt(int x, int y) // Get Item at position (x, y). // Returns null if position (x, y) does not contain an item. public Item GetItemAt(int x, int y) // Get Item at position. // Returns null if position does not contain an item. public Item GetItemAt(Vector2 position) // Returns true if slot (x, y) contains an item. public bool HasItem(int x, int y) // Returns true if slot at position contains an item. public bool HasItem(Vector2 position) // Returns true if slot at (x, y) contains an item. // itemIndex carries the index of item at (x, y). -1 is no item. public bool HasItem(int x, int y, out int itemIndex) // Returns true if slot at position contains an item. // itemIndex carries the index of item at position. -1 is no item. public bool HasItem(Vector2 position, out int itemIndex) // Returns true if slot at (x, y) contains an item. // item carries the item at (x, y). null if empty. public bool HasItem(int x, int y, out Item item) // Returns true if slot at position contains an item. // item carries the item at position. null if empty. public bool HasItem(Vector2 position, out Item item) // Place held item in the inventory at (x, y). // Swaps items if slot already has item. public void PlaceHeldItem(int x, int y) // Place held item in the inventory at position. // Swaps items if slot already has item. public void PlaceHeldItem(Vector2 position) // Stashes any held item in the first eligible slot. // Returns false if there is no place in the inventory for the Item. // Calls inputObject's OnTossHand(ref Slot hand) method before emptying hand if operation failed. public bool StashHeldItem() // Pick up a certain number of items from slot. // Places/ Swaps item if hand already has item. // If pickUpOneIfSame, picks up one item at (x, y) if hand item is the same as slot item. public void PickUpStack(int x, int y, int count, bool pickUpOneIfSame = false) // Places count items from hand into slot (x, y). // Swaps items if hand item is different from slot item. public void PlaceHeldStack(int x, int y, int count) // Inserts item into slot (x, y) with a stack of count. // Unsafe! (Overrides any item already at x, y) public void InsertItem(Item item, int x, int y, int count = 1) // Places count items in the first available slot. // Adds to stack if possible. // Calls inputObject's OnTossItem(ref Item item) method before emptying hand if operation failed. public bool PlaceItem(Item item, int count = 1) // Place item as specified slot. // Calls inputObject's OnTossItem() method before emptying hand if operation failed. public bool PlaceItem(Item item, int x, int y, int count = 1)","title":"Methods"},{"location":"inventory/#inventoryrenderer","text":"","title":"Inventory.Renderer"},{"location":"inventory/#description_1","text":"","title":"Description"},{"location":"inventory/#static-properties","text":"","title":"Static Properties"},{"location":"inventory/#properties_1","text":"","title":"Properties"},{"location":"inventory/#methods_1","text":"","title":"Methods"},{"location":"inventory/#inventorymeshdata","text":"","title":"Inventory.MeshData"},{"location":"inventory/#description_2","text":"","title":"Description"},{"location":"inventory/#static-properties_1","text":"","title":"Static Properties"},{"location":"inventory/#properties_2","text":"","title":"Properties"},{"location":"inventory/#methods_2","text":"","title":"Methods"},{"location":"inventory/#inventoryslotdata","text":"","title":"Inventory.SlotData"},{"location":"inventory/#description_3","text":"","title":"Description"},{"location":"inventory/#static-properties_2","text":"","title":"Static Properties"},{"location":"inventory/#properties_3","text":"","title":"Properties"},{"location":"inventory/#methods_3","text":"","title":"Methods"},{"location":"inventory/#slot","text":"","title":"Slot"},{"location":"inventory/#description_4","text":"","title":"Description"},{"location":"inventory/#properties_4","text":"","title":"Properties"},{"location":"inventory/#methods_4","text":"","title":"Methods"},{"location":"item-shelf/","text":"The Item Shelf Description The ItemShelf is a scriptableObject that holds data about all the items you set up, and the Inventory system unity package comes with a preconfigured ItemShelf containing a few items to help you get started. The ItemShelf has to be located in a /Resources/ folder. There can only be one ItemShelf per project. Static Properties public static int ItemCount; // Returns the current Item count in the ItemShelf. public static Item Random; // Returns a random item from the ItemShelf. Properties public List<Entry> entries // A list of all the Item entries in the ItemShelf. // use ItemShelf.GetInstance().entries; public string ResourcePath { private get; set; } // The resource path of the scriptableObject. // use ItemShelf.GetInstance().ResourcePath; Public Methods public void UpdateResourcePath(ItemShelf shelf) // Updates and saves the current Resource path of the ItemShelf scriptableObject. // his is called automatically when the scriptableObject path has changed. Static Methods public static ItemShelf GetInstance // Returns the static instance of the ItemShelf. // Loads the instance if it isn't loaded. public static Item GetItem(int index) // Returns Item at entries[index]. public static Item GetItem(string name) // Returns Item with name 'name'. public static Item GetItem<T>(int index) where T : Item // Returns Item at entries[index] as type T. Public static bool HasItem(int index) // Returns true if itemShelf contains item at index. Public static bool HasItem(string name) // Returns true if itemShelf contains item with name.","title":"Item Shelf"},{"location":"item-shelf/#the-item-shelf","text":"","title":"The Item Shelf"},{"location":"item-shelf/#description","text":"The ItemShelf is a scriptableObject that holds data about all the items you set up, and the Inventory system unity package comes with a preconfigured ItemShelf containing a few items to help you get started. The ItemShelf has to be located in a /Resources/ folder. There can only be one ItemShelf per project.","title":"Description"},{"location":"item-shelf/#static-properties","text":"public static int ItemCount; // Returns the current Item count in the ItemShelf. public static Item Random; // Returns a random item from the ItemShelf.","title":"Static Properties"},{"location":"item-shelf/#properties","text":"public List<Entry> entries // A list of all the Item entries in the ItemShelf. // use ItemShelf.GetInstance().entries; public string ResourcePath { private get; set; } // The resource path of the scriptableObject. // use ItemShelf.GetInstance().ResourcePath;","title":"Properties"},{"location":"item-shelf/#public-methods","text":"public void UpdateResourcePath(ItemShelf shelf) // Updates and saves the current Resource path of the ItemShelf scriptableObject. // his is called automatically when the scriptableObject path has changed.","title":"Public Methods"},{"location":"item-shelf/#static-methods","text":"public static ItemShelf GetInstance // Returns the static instance of the ItemShelf. // Loads the instance if it isn't loaded. public static Item GetItem(int index) // Returns Item at entries[index]. public static Item GetItem(string name) // Returns Item with name 'name'. public static Item GetItem<T>(int index) where T : Item // Returns Item at entries[index] as type T. Public static bool HasItem(int index) // Returns true if itemShelf contains item at index. Public static bool HasItem(string name) // Returns true if itemShelf contains item with name.","title":"Static Methods"}]}