{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My Inventory Documentation An Inventory System by Erik (Sandpile) S\u00e4nd. Description My inventory is an Inventory system designed to be easy to use, yet flexible and customizable enough for you to be able to achieve Any inventory look you want ranging from Animal Crossing, to Stardew Valley and Minecraft, all inside the Unity game engine. Every look is achievable using My Inventory! Purchasing My Inventory from the Unity Asset Store gives you access to all the source files and code that builds My Inventory. You can then edit or add new fundamental features directly to the source code if you wish. The My Inventory system If you find a feature is missing, contact me at ErikSandpile@gmail.com and I will try to help! Getting Started My Inventory is distributed in a system of trust, and re-distributing my code breaks that trust. If you find a bug, or believe you found a missing feature, you can submit a support ticket here Creating an Inventory Skin Before anything, you need to decide how your inventory should look, and to do that you need to create and configure an InventorySkin . To create an InventorySkin , right-click in your asset browser, Create > Inventory > Inventory Skin In your InventorySkin you can add sprites for the different elements of your inventory. If you want all the different sprites of your inventory to have the same pixel size, all of your sprite assets should have the same 'Pixels Per Unit' value. When you have added your sprites and optionally a font to your InventorySkin , it helps to have your inventory display on the screen before tweaking the other settings. An InventorySkin can be modified at runtime through the inspector, and we will take advantage of this to easily see our inventory get updated as we modify our InventorySkin . Keep in mind that not all of the InventorySkin variables support runtime editing, and you might occasionally need to restart your game to see changes. /// To setup a basic inventory, you first need to configure an InventorySkin scriptableObject to reference. You also need to create a Canvas object in your scene, and add an InventoryImage as a child of the Canvas. fix canvas settings In a new script, add this: public Inventory inventory; public InventorySkin skin; public InventoryImage image; void Awake() { inventory = Inventory.Load(\"player_inventory\", skin); } void Update() { inventory.Draw(image); } Now when you start the unity player, you should see an inventory on the screen. Adding items You will realize that there are no items in your inventory. To add an item to a slot, after loading your inventory you can use inventory.PlaceItem(ItemShelf.Random, 0, 0, 1); This will take a random item from the ItemShelf, and place it in slot(0, 0) with a count of 1.","title":"Home"},{"location":"#my-inventory-documentation","text":"An Inventory System by Erik (Sandpile) S\u00e4nd.","title":"My Inventory Documentation"},{"location":"#description","text":"My inventory is an Inventory system designed to be easy to use, yet flexible and customizable enough for you to be able to achieve Any inventory look you want ranging from Animal Crossing, to Stardew Valley and Minecraft, all inside the Unity game engine. Every look is achievable using My Inventory! Purchasing My Inventory from the Unity Asset Store gives you access to all the source files and code that builds My Inventory. You can then edit or add new fundamental features directly to the source code if you wish. The My Inventory system If you find a feature is missing, contact me at ErikSandpile@gmail.com and I will try to help!","title":"Description"},{"location":"#getting-started","text":"My Inventory is distributed in a system of trust, and re-distributing my code breaks that trust. If you find a bug, or believe you found a missing feature, you can submit a support ticket here","title":"Getting Started"},{"location":"#creating-an-inventory-skin","text":"Before anything, you need to decide how your inventory should look, and to do that you need to create and configure an InventorySkin . To create an InventorySkin , right-click in your asset browser, Create > Inventory > Inventory Skin In your InventorySkin you can add sprites for the different elements of your inventory. If you want all the different sprites of your inventory to have the same pixel size, all of your sprite assets should have the same 'Pixels Per Unit' value. When you have added your sprites and optionally a font to your InventorySkin , it helps to have your inventory display on the screen before tweaking the other settings. An InventorySkin can be modified at runtime through the inspector, and we will take advantage of this to easily see our inventory get updated as we modify our InventorySkin . Keep in mind that not all of the InventorySkin variables support runtime editing, and you might occasionally need to restart your game to see changes. /// To setup a basic inventory, you first need to configure an InventorySkin scriptableObject to reference. You also need to create a Canvas object in your scene, and add an InventoryImage as a child of the Canvas. fix canvas settings In a new script, add this: public Inventory inventory; public InventorySkin skin; public InventoryImage image; void Awake() { inventory = Inventory.Load(\"player_inventory\", skin); } void Update() { inventory.Draw(image); } Now when you start the unity player, you should see an inventory on the screen.","title":"Creating an Inventory Skin"},{"location":"#adding-items","text":"You will realize that there are no items in your inventory. To add an item to a slot, after loading your inventory you can use inventory.PlaceItem(ItemShelf.Random, 0, 0, 1); This will take a random item from the ItemShelf, and place it in slot(0, 0) with a count of 1.","title":"Adding items"},{"location":"about/","text":"Meo manibus Ignavos fit Lorem markdownum pauperque mavult mota, nec tuum inductas dubitare. Qui dominae , necat huic squamae, illic esse signant tendat. Neque nullos pectora. Liberat et vidit mandata iaculum Alexiroe bis egens minimas Nereis in maduere hamis. Cum mollia et Priamum consultus. Visa advertitur spargitque tempora venere fumantiaque doloris flectere at atria posset possedit. Vincas idcirco conveniunt flumine flere, nulli rursusque Martius , pectore. Quoque lucis hic rebus; est meris fuga veluti quo. Iam quod, orbe aequor crescentemque sede quondamque detque . Clarissimus galeae Illis et vitat caelamina, id sic iura sed ferrum. Ipsos vidi dum manu, ac casus in duos, tale iter, Phocus canosque in feruntur, nec in? Nec nimiumque novae, quot Scylla fontem zonarumque ferre, curru suae omnibus; ortu dixi a umbra! Guttura iusta remitti frontes latebris carmina subiectos Cepheaque tamen pars! Fluviis rerum quae relicto pectora erit Dianam nubila a longi scopulo piget perstat exierant aemula, suco ipse? Cultros stantemque praemia addidit: est longum expositum enim subiectis. Deseruere credar illa iunctum domoque Lavini ratibusque hostes. Post aurea formatae iuppiter in, hoc, ego nec perdet. Passosque tempus conubia et humus ambagibus mihi remansit facit, non. Verba persequar etiamnum, quia deme sub est, volui vidi pedibus factum . Cum in hortamine gelidis salices, et auras coercet dictoque habebat dedit eloquioque haec. Terrasque taedia, exire misit patet foro grata largis penetralia recentes ambiguum septem superat sui. Interea utque soror effugit pia otia frustra culta. Regia sistite quibus Cydoneasque, inane; patuisset aere carpitur, frustra quoniam. Per quorum indignata dum patera corna. Omnia adeo Curetas Ira caeli puppim illa contraria illa ingens fallere. Murmure errante investigata bella nobis: urbem quas, Hodites. Duce via quidem iussa igne exstabant inquit Tubere regnata et Taenaria dea nec Cadmi Nec prius inani tanta altera Rate infestus dantibus primos super vires conceptus Invitusque Aetnaea plumis dubitati es decidit sequentem Phoebo conataeque ac desunt alite Veneris et fatebor visu causa dolori locumque per ingens medulla, nec mariti in! Residant malis et removi nec: longa nunc, Palilibus urbe specie, prohibebar, Quae agri. Domus non, umor fontes, alto socerum solum forma filia. Capit superest; velamina et armis minorque, amoris Scyrumve, mirabile muro: petet maris meminisse quotiens.","title":"Meo manibus"},{"location":"about/#meo-manibus","text":"","title":"Meo manibus"},{"location":"about/#ignavos-fit","text":"Lorem markdownum pauperque mavult mota, nec tuum inductas dubitare. Qui dominae , necat huic squamae, illic esse signant tendat. Neque nullos pectora. Liberat et vidit mandata iaculum Alexiroe bis egens minimas Nereis in maduere hamis. Cum mollia et Priamum consultus. Visa advertitur spargitque tempora venere fumantiaque doloris flectere at atria posset possedit. Vincas idcirco conveniunt flumine flere, nulli rursusque Martius , pectore. Quoque lucis hic rebus; est meris fuga veluti quo. Iam quod, orbe aequor crescentemque sede quondamque detque .","title":"Ignavos fit"},{"location":"about/#clarissimus-galeae","text":"Illis et vitat caelamina, id sic iura sed ferrum. Ipsos vidi dum manu, ac casus in duos, tale iter, Phocus canosque in feruntur, nec in? Nec nimiumque novae, quot Scylla fontem zonarumque ferre, curru suae omnibus; ortu dixi a umbra! Guttura iusta remitti frontes latebris carmina subiectos Cepheaque tamen pars! Fluviis rerum quae relicto pectora erit Dianam nubila a longi scopulo piget perstat exierant aemula, suco ipse? Cultros stantemque praemia addidit: est longum expositum enim subiectis. Deseruere credar illa iunctum domoque Lavini ratibusque hostes. Post aurea formatae iuppiter in, hoc, ego nec perdet. Passosque tempus conubia et humus ambagibus mihi remansit facit, non. Verba persequar etiamnum, quia deme sub est, volui vidi pedibus factum . Cum in hortamine gelidis salices, et auras coercet dictoque habebat dedit eloquioque haec. Terrasque taedia, exire misit patet foro grata largis penetralia recentes ambiguum septem superat sui. Interea utque soror effugit pia otia frustra culta. Regia sistite quibus Cydoneasque, inane; patuisset aere carpitur, frustra quoniam. Per quorum indignata dum patera corna.","title":"Clarissimus galeae"},{"location":"about/#omnia-adeo-curetas","text":"Ira caeli puppim illa contraria illa ingens fallere. Murmure errante investigata bella nobis: urbem quas, Hodites. Duce via quidem iussa igne exstabant inquit Tubere regnata et Taenaria dea nec Cadmi Nec prius inani tanta altera Rate infestus dantibus primos super vires conceptus Invitusque Aetnaea plumis dubitati es decidit sequentem Phoebo conataeque ac desunt alite Veneris et fatebor visu causa dolori locumque per ingens medulla, nec mariti in! Residant malis et removi nec: longa nunc, Palilibus urbe specie, prohibebar, Quae agri. Domus non, umor fontes, alto socerum solum forma filia. Capit superest; velamina et armis minorque, amoris Scyrumve, mirabile muro: petet maris meminisse quotiens.","title":"Omnia adeo Curetas"},{"location":"inventory-image/","text":"Inventory Image inherits from RawImage Description The InventoryImage is a UI object on the Canvas, that displays the Inventory.TextureRenderer texture to the screen. Create an InventoryImage by right-clicking in your hierarchy, UI > InventoryImage. Properties // the editorSkin will display the inventory background accurately on the screen in the editor. public InventorySkin editorSkin Methods // public void Draw(Inventory inventory)","title":"Inventory Image"},{"location":"inventory-image/#inventory-image","text":"inherits from RawImage","title":"Inventory Image"},{"location":"inventory-image/#description","text":"The InventoryImage is a UI object on the Canvas, that displays the Inventory.TextureRenderer texture to the screen. Create an InventoryImage by right-clicking in your hierarchy, UI > InventoryImage.","title":"Description"},{"location":"inventory-image/#properties","text":"// the editorSkin will display the inventory background accurately on the screen in the editor. public InventorySkin editorSkin","title":"Properties"},{"location":"inventory-image/#methods","text":"// public void Draw(Inventory inventory)","title":"Methods"},{"location":"inventory-input/","text":"Input Handler Description The InputHandler is a base class holding virtual methods called at certain points when an inventory is rendering. It is possible to create custom functionality for your Inventory by overriding these methods in a custom class, and using Inventory.SetInputObject() , passing in your InventoryHandler object. Virtual Methods // Called when any slot of inventory is hovered over. // index is the position of the slot in the Inventory.Slots array public virtual void OnHoverSlot(Inventory inventory, int index) // Called whenever the cursor isn't hovering over any inventory on the screen. // Only called whenever at least one inventory is being rendered. public virtual void OnHoverOverVoid() // Called once for every slot, every frame. // Useful for using slot.SetItemScale and slot.SetItemPosition depending on slot.State. public virtual void OnSlot(Inventory inventory, ref Slot slot, Vector2 pos) // Called whenever inventory starts being drawn using the inventory.Draw() method. public virtual void OnStartDraw(Inventory inventory) // Called whenever inventory stops being drawn using the inventory.Draw() method. public virtual void OnStopDraw(Inventory inventory) // Called when hand item fails to fit anywhere in inventory using StashHeldItem(). // count is the amount of items to toss from hand. public virtual void OnTossHand(int count) // Called whenever items tries to enter the inventory but fails. // If items are not taken care of in this method, they will be lost. public virtual void OnTossItem(ref Item item, int count) // Called by the inventory to find out where the cursor is. // Don't override this method, and it will return Input.mousePosition. public virtual Vector2 GetCursorPosition()","title":"Input Handler"},{"location":"inventory-input/#input-handler","text":"","title":"Input Handler"},{"location":"inventory-input/#description","text":"The InputHandler is a base class holding virtual methods called at certain points when an inventory is rendering. It is possible to create custom functionality for your Inventory by overriding these methods in a custom class, and using Inventory.SetInputObject() , passing in your InventoryHandler object.","title":"Description"},{"location":"inventory-input/#virtual-methods","text":"// Called when any slot of inventory is hovered over. // index is the position of the slot in the Inventory.Slots array public virtual void OnHoverSlot(Inventory inventory, int index) // Called whenever the cursor isn't hovering over any inventory on the screen. // Only called whenever at least one inventory is being rendered. public virtual void OnHoverOverVoid() // Called once for every slot, every frame. // Useful for using slot.SetItemScale and slot.SetItemPosition depending on slot.State. public virtual void OnSlot(Inventory inventory, ref Slot slot, Vector2 pos) // Called whenever inventory starts being drawn using the inventory.Draw() method. public virtual void OnStartDraw(Inventory inventory) // Called whenever inventory stops being drawn using the inventory.Draw() method. public virtual void OnStopDraw(Inventory inventory) // Called when hand item fails to fit anywhere in inventory using StashHeldItem(). // count is the amount of items to toss from hand. public virtual void OnTossHand(int count) // Called whenever items tries to enter the inventory but fails. // If items are not taken care of in this method, they will be lost. public virtual void OnTossItem(ref Item item, int count) // Called by the inventory to find out where the cursor is. // Don't override this method, and it will return Input.mousePosition. public virtual Vector2 GetCursorPosition()","title":"Virtual Methods"},{"location":"inventory-skin/","text":"Inventory Skin Description An InventorySkin holds all of the data pertaining to the look of your Inventory . All properties on an InventorySkin is local to a certain Inventory, and you can use different InventorySkins for different Inventories. However, some properties are advised to keep same across all of your inventories in a single project. These properties are marked with a * star . InventorySkin properties are not meant to be changed in runtime, but some properties have the ability to, such as material, Z positions, offsets and the different sprites. Properties //The size of your inventory determines the amount of slots it has on the x and y axis. public Vector2 size // The base material used by the inventory. // Use a Sprites/Default material if you're not sure. public Material material // The type of text to use for item stack count. // Can be Font, Sprite or None. public InventorySkin.TextType textType // The font to use if textType is font. public Font font // The size of the font. public float fontSize; // The style of the font. public FontStyle fontStyle // The color of the font. public Color fontColor; // Populate this array with number 0-9 if textType is Sprite. public Sprite[] numberSprites // The offset for all of the text instances in pixels. // Default is center of each slot. public Vector2 textPixelOffset // The spacing between numbers, in pixels. public float textSpacing // The order of the slots. Can be TopToBottom or BottomToTop. public SlotOrder slotOrder // Item stacks in a slot can not exceed this value. public int maxItemStack // The number of frames rendered per second. // Keep this number relatively low to improve performance (60 is good). *public int framesPerSecond // Texture subdivision. n means each pixel is subdivided into n*n pixels. // Higher number can produce smoother cursor movement. // Recommened to keep above 1 with lower pixel density sprites to avoid artifacts. *public int textureSubDivision // The sprite used for the background of the inventory. // Sprite pixels Per Unit should be the same as slot Pixels Per Unit. public Sprite background // Sprites used for the different slot states. // Sprite pixels Per Unit should be the side length of the slot. public Sprite slot public Sprite slotHover public Sprite slotLocked // The uniform slot offset relative to the background, in pixels. public Vector2 slotPixelOffset // The uniform spacing between all of the slots, in pixels. public Vector2 slotPixelSpacing // The pixel amount to expand or shrink the area around the slot. // This area checks for cursor position overlap to determine slot state. public float slotSelectPixelExpand // the Z position of different elements of the inventory. // Use renderQueue variables instead to visually order elements. public float slotZ public float itemZ public float textZ public float handZ // The renderQueue of the different elements of the inventory. public int background_renderQueue public int slot_renderQueue public int item_renderQueue public int text_renderQueue public int handItem_renderQueue public int handText_renderQueue // The held item offset relative to the cursor position, in pixels. *public Vector2 handPixelOffset // Determines if the held item is snapped to the pixel grid. *public bool snapHandPosition // Holds all the information about individual slot offsets. public InventoryOffsetData offsetData InventoryOffsetData InventoryOffsetData holds all the information about individual slot offsets in an InventorySkin. InventoryOffsetData makes it possible to select several slots, and move them a few pixels in any direction as you see fit. Properties // An array containing all the user defined offsets. public Offset[] offsets Methods // Adds an empty offset to the end of the offsets list. public void AddOffset() // Removes the offset at index from the offsets list. public void RemoveOffset(int index) // Get offset of slot at position, in pixels public Vector2 GetOffset(Vector2 position) InventoryOffsetData.Offset Properties // Positions of Inventory slots affected by this offset. public List<Vector2> positions // Value to offset slots in positions list by, in pixels. public Vector2 value","title":"Inventory Skin"},{"location":"inventory-skin/#inventory-skin","text":"","title":"Inventory Skin"},{"location":"inventory-skin/#description","text":"An InventorySkin holds all of the data pertaining to the look of your Inventory . All properties on an InventorySkin is local to a certain Inventory, and you can use different InventorySkins for different Inventories. However, some properties are advised to keep same across all of your inventories in a single project. These properties are marked with a * star . InventorySkin properties are not meant to be changed in runtime, but some properties have the ability to, such as material, Z positions, offsets and the different sprites.","title":"Description"},{"location":"inventory-skin/#properties","text":"//The size of your inventory determines the amount of slots it has on the x and y axis. public Vector2 size // The base material used by the inventory. // Use a Sprites/Default material if you're not sure. public Material material // The type of text to use for item stack count. // Can be Font, Sprite or None. public InventorySkin.TextType textType // The font to use if textType is font. public Font font // The size of the font. public float fontSize; // The style of the font. public FontStyle fontStyle // The color of the font. public Color fontColor; // Populate this array with number 0-9 if textType is Sprite. public Sprite[] numberSprites // The offset for all of the text instances in pixels. // Default is center of each slot. public Vector2 textPixelOffset // The spacing between numbers, in pixels. public float textSpacing // The order of the slots. Can be TopToBottom or BottomToTop. public SlotOrder slotOrder // Item stacks in a slot can not exceed this value. public int maxItemStack // The number of frames rendered per second. // Keep this number relatively low to improve performance (60 is good). *public int framesPerSecond // Texture subdivision. n means each pixel is subdivided into n*n pixels. // Higher number can produce smoother cursor movement. // Recommened to keep above 1 with lower pixel density sprites to avoid artifacts. *public int textureSubDivision // The sprite used for the background of the inventory. // Sprite pixels Per Unit should be the same as slot Pixels Per Unit. public Sprite background // Sprites used for the different slot states. // Sprite pixels Per Unit should be the side length of the slot. public Sprite slot public Sprite slotHover public Sprite slotLocked // The uniform slot offset relative to the background, in pixels. public Vector2 slotPixelOffset // The uniform spacing between all of the slots, in pixels. public Vector2 slotPixelSpacing // The pixel amount to expand or shrink the area around the slot. // This area checks for cursor position overlap to determine slot state. public float slotSelectPixelExpand // the Z position of different elements of the inventory. // Use renderQueue variables instead to visually order elements. public float slotZ public float itemZ public float textZ public float handZ // The renderQueue of the different elements of the inventory. public int background_renderQueue public int slot_renderQueue public int item_renderQueue public int text_renderQueue public int handItem_renderQueue public int handText_renderQueue // The held item offset relative to the cursor position, in pixels. *public Vector2 handPixelOffset // Determines if the held item is snapped to the pixel grid. *public bool snapHandPosition // Holds all the information about individual slot offsets. public InventoryOffsetData offsetData","title":"Properties"},{"location":"inventory-skin/#inventoryoffsetdata","text":"InventoryOffsetData holds all the information about individual slot offsets in an InventorySkin. InventoryOffsetData makes it possible to select several slots, and move them a few pixels in any direction as you see fit.","title":"InventoryOffsetData"},{"location":"inventory-skin/#properties_1","text":"// An array containing all the user defined offsets. public Offset[] offsets","title":"Properties"},{"location":"inventory-skin/#methods","text":"// Adds an empty offset to the end of the offsets list. public void AddOffset() // Removes the offset at index from the offsets list. public void RemoveOffset(int index) // Get offset of slot at position, in pixels public Vector2 GetOffset(Vector2 position)","title":"Methods"},{"location":"inventory-skin/#inventoryoffsetdataoffset","text":"","title":"InventoryOffsetData.Offset"},{"location":"inventory-skin/#properties_2","text":"// Positions of Inventory slots affected by this offset. public List<Vector2> positions // Value to offset slots in positions list by, in pixels. public Vector2 value","title":"Properties"},{"location":"inventory/","text":"Inventory Description An Inventory is an object that takes care of drawing an inventory on the screen with help from an InventorySkin and an InventoryImage . The behaviour of an Inventory can be altered using an InputHandler object. Static Properties // the ID of the inventory the cursor is hovering over. // -1 if no inventory is hovered over. public static int hoverInventory { get; } // the index of the slot the cursor is hovering over. // -1 if no slot is hovered over. public static int hoverSlot { get; } Properties // The unique ID of the inventory. public int ID // The filename of the save file of the inventory slot array. public string FileName // The current InventorySkin used by the Inventory. public InventorySkin skin // The Slot data of the Inventory. public SlotData slotData // A shortcut for slotData.slots[] public Slot[] Slots // Is the inventory being drawn using the inventory.Draw() method? public bool IsDrawing { get; } Static Methods // Loads an inventory from file, or creates a new inventory if no file was found. // Inventory i = Inventory.Load(...); public static Inventory Load(string fileName, InventorySkin skin, bool forceNew = false) // Mark the Inventory system to update the texture size next update. // Usefull after changing aspect ratio. public static void MarkForNewRenderTexture() // Set an InputObject to allow custom behavior written by the user. // See InputHandler for more information. public static void SetInputObject(InputHandler _object) // Get the InputHandler currently in use. (Null if none) // See InputHandler for more information. public static InputHandler GetInputObject() Methods // Reload slotData.slots[] array from last save as FileName. public void Reload() // Save the current slotData.slots[] array as FileName. public void Save() // Save the current slotData.slots[] array as specified fileName. public void Save(string fileName) // Update the Inventory, and draw it on image // according to the inventorySkin.framesPerSecond property. public void Draw(InventoryImage image) // Get Item Index at position (x, y). // Returns -1 if Slot(x, y) doesn't contain an item. public int GetItemIndexAt(int x, int y) // Get Item at position (x, y). // Returns null if position (x, y) does not contain an item. public Item GetItemAt(int x, int y) // Get Item at position. // Returns null if position does not contain an item. public Item GetItemAt(Vector2 position) // Returns true if slot (x, y) contains an item. public bool HasItem(int x, int y) // Returns true if slot at position contains an item. public bool HasItem(Vector2 position) // Returns true if slot at (x, y) contains an item. // itemIndex carries the index of item at (x, y). -1 is no item. public bool HasItem(int x, int y, out int itemIndex) // Returns true if slot at position contains an item. // itemIndex carries the index of item at position. -1 is no item. public bool HasItem(Vector2 position, out int itemIndex) // Returns true if slot at (x, y) contains an item. // item carries the item at (x, y). null if empty. public bool HasItem(int x, int y, out Item item) // Returns true if slot at position contains an item. // item carries the item at position. null if empty. public bool HasItem(Vector2 position, out Item item) // Place held item in the inventory at (x, y). // Swaps items if slot already has item. public void PlaceHeldItem(int x, int y) // Place held item in the inventory at position. // Swaps items if slot already has item. public void PlaceHeldItem(Vector2 position) // Place held item in the inventory slot at index. // Swaps items if slot already has item. public void PlaceHeldItem(int index) // Stashes any held item in the first eligible slot. // Returns false if there is no place in the inventory for the Item. // Calls inputObject's OnTossHand(ref Slot hand) method before emptying hand if operation failed. public bool StashHeldItem() // Pick up a certain number of items from slot (x, y). // Places/ Swaps item if hand already has item. public void PickUpStack(int x, int y, int count) // Pick up a certain number of items from slot at index. // Places/ Swaps item if hand already has item. public void PickUpStack(int index, int count) // Places count items from hand into slot (x, y). // Swaps items if hand item is different from slot item. public void PlaceHeldStack(int x, int y, int count) // Places count items from hand into slot at index. // Swaps items if hand item is different from slot item. public void PlaceHeldStack(int index, int count) // Inserts item into slot (x, y) with a stack of count. // Unsafe! (Overrides any item already at x, y) public void InsertItem(Item item, int x, int y, int count = 1) // Places count items in the first available slot. // Adds to stack if possible. // Calls inputObject's OnTossItem(ref Item item) method before emptying hand if operation failed. public bool PlaceItem(Item item, int count = 1) // Place item as specified slot. // Calls inputObject's OnTossItem() method before emptying hand if operation failed. public bool PlaceItem(Item item, int x, int y, int count = 1) Inventory.TextureRenderer Description The TextureRenderer takes care of rendering the Inventory to a RenderTexture . Static Properties // The RenderTexture with a rendering of the inventories being drawn. public static RenderTexture Texture { get; } //The UI object displaying the render texture on the canvas. public static RawImage UIObject { get;} // Pixels per unit. // Based on latest initiated inventory background sprite pixelsPerUnit. public static float PPU // Units per pixel. // 1 / PPU public static float UPP Properties public MeshData MeshData { get; } // Is this inventory the first inventory being rendered this frame? // Holds data of last rendered frame if no inventory has been rendered this frame. public bool IsFirstRenderer { get; } // The RectTransform of the InventoryImage being rendered to. public RectTransform RectTransform { get; } // The RectTransform of the Canvas parenting the image being rendered to. public RectTransform CanvasRectTransform { get; } // Bounds of the inventory in world space. public Bounds Bounds { get; } Methods // public void Update(Inventory inventory, InventoryImage image) [TODO] // Get position of the cursor relative to the render mesh. // (0, 0) is center of the inventory. public Vector2 GetHandPosition(Inventory inv, bool pixelSnap = false) // Get position of the inventory in world space. // (0, 0) is center of the render camera / canvas. public Vector3 GetInventoryPosition(Inventory inventory, bool pixelSnap = false) Inventory.MeshData Description The Inventory MeshData builds the inventory mesh to be rendered by the TextureRenderer. Static Properties // Is the cursor hovering over any inventory meshes rendering to the screen? public static bool CursorIsOverMesh { get; } Properties // The Inventory mesh. // Shortcut for mf.sharedMesh. public Mesh Mesh { get; } // The MeshRenderer of the Inventory. public MeshRenderer mr { get; } // The MeshFilter of the Inventory. public MeshFilter mf { get;} // The object rendering the Inventory mesh. public GameObject MeshObject { get; } // Bounds of the inventory background in world space. public Bounds BackgroundBounds { get; } Constructors // Creates a new MeshData. public MeshData() Methods // Update mesh data. Is called through Inventory.Draw(InventoryImage image) public void Update(Inventory inventory) Inventory.SlotData Description SlotData holds all the slots, and the items contained in them. Static Properties // The hand, containing the held item. public static Slot hand { get; set; } Properties // The size of the inventory in slots. public Vector2 size { get; } // The number of slots horizontally. public int CountX // The number of slots vertically. public int CountY // The slot array of the inventory. public Slot[] slots Constructors // Creates a new SlotData. Size is slot count on x and y of inventory. public SlotData(Vector2 size) Methods // Takes a slot (x, y) position and returns the array index. public int PositionToIndex(int x, int y, InventorySkin.SlotOrder order = SlotOrder.TopToBottom) // Takes a slot index in the array, and returns the (x ,y) position. public Vector2 IndexToPosition(int i, InventorySkin.SlotOrder order = SlotOrder.TopToBottom) // Clears highlighted slot, and reset ItemPosition and Item Scale for each slot. public void ResetSlotStates() Slot Description A slot containing an item and a stack count. Properties // the ID of the item held in slot. public int heldItemID // Get the stack count of the item in slot. public Stack { get; } // Is the slot locked? public bool IsLocked { get; } // The State of the slot. Can be Open, Locked, or highlighted. public UseState State { get; } // The scale of the item sprite in slot. Update this value with SetItemScale(float scale). public ItemScale { get; } // Get the position of the item sprite in slot. public Vector2 ItemPosition { get; } Constructors // Create a new Slot. public Slot(int heldItem, int stack = 0, UseState state = UseState.Open) Methods // Set the scale of the item sprite in slot. public void SetItemScale(float scale) // Set the position of the item sprite in slot. public void SetItemPosition(float x, float y) // Sets the item stack to value public void SetStack(int value) // Add or remove from item stack. Use AddToStackSmart to adhere to maxItemStack. public void AddToStack(int count) // Add or remove from item stack. // ref count is the amount of items to add, // and it returns the item count that potentially did not fit in slot. public void AddToStackSmart(ref int count, int maxItemStack) // Sets the UseState to Locked. public void Lock() // Sets the UseState to Open. public void Open() // Update slot state. public void UpdateState(UseState state) // Update heldItemID and stack of slot. public void Update(int heldItem, int stack)","title":"Inventory"},{"location":"inventory/#inventory","text":"","title":"Inventory"},{"location":"inventory/#description","text":"An Inventory is an object that takes care of drawing an inventory on the screen with help from an InventorySkin and an InventoryImage . The behaviour of an Inventory can be altered using an InputHandler object.","title":"Description"},{"location":"inventory/#static-properties","text":"// the ID of the inventory the cursor is hovering over. // -1 if no inventory is hovered over. public static int hoverInventory { get; } // the index of the slot the cursor is hovering over. // -1 if no slot is hovered over. public static int hoverSlot { get; }","title":"Static Properties"},{"location":"inventory/#properties","text":"// The unique ID of the inventory. public int ID // The filename of the save file of the inventory slot array. public string FileName // The current InventorySkin used by the Inventory. public InventorySkin skin // The Slot data of the Inventory. public SlotData slotData // A shortcut for slotData.slots[] public Slot[] Slots // Is the inventory being drawn using the inventory.Draw() method? public bool IsDrawing { get; }","title":"Properties"},{"location":"inventory/#static-methods","text":"// Loads an inventory from file, or creates a new inventory if no file was found. // Inventory i = Inventory.Load(...); public static Inventory Load(string fileName, InventorySkin skin, bool forceNew = false) // Mark the Inventory system to update the texture size next update. // Usefull after changing aspect ratio. public static void MarkForNewRenderTexture() // Set an InputObject to allow custom behavior written by the user. // See InputHandler for more information. public static void SetInputObject(InputHandler _object) // Get the InputHandler currently in use. (Null if none) // See InputHandler for more information. public static InputHandler GetInputObject()","title":"Static Methods"},{"location":"inventory/#methods","text":"// Reload slotData.slots[] array from last save as FileName. public void Reload() // Save the current slotData.slots[] array as FileName. public void Save() // Save the current slotData.slots[] array as specified fileName. public void Save(string fileName) // Update the Inventory, and draw it on image // according to the inventorySkin.framesPerSecond property. public void Draw(InventoryImage image) // Get Item Index at position (x, y). // Returns -1 if Slot(x, y) doesn't contain an item. public int GetItemIndexAt(int x, int y) // Get Item at position (x, y). // Returns null if position (x, y) does not contain an item. public Item GetItemAt(int x, int y) // Get Item at position. // Returns null if position does not contain an item. public Item GetItemAt(Vector2 position) // Returns true if slot (x, y) contains an item. public bool HasItem(int x, int y) // Returns true if slot at position contains an item. public bool HasItem(Vector2 position) // Returns true if slot at (x, y) contains an item. // itemIndex carries the index of item at (x, y). -1 is no item. public bool HasItem(int x, int y, out int itemIndex) // Returns true if slot at position contains an item. // itemIndex carries the index of item at position. -1 is no item. public bool HasItem(Vector2 position, out int itemIndex) // Returns true if slot at (x, y) contains an item. // item carries the item at (x, y). null if empty. public bool HasItem(int x, int y, out Item item) // Returns true if slot at position contains an item. // item carries the item at position. null if empty. public bool HasItem(Vector2 position, out Item item) // Place held item in the inventory at (x, y). // Swaps items if slot already has item. public void PlaceHeldItem(int x, int y) // Place held item in the inventory at position. // Swaps items if slot already has item. public void PlaceHeldItem(Vector2 position) // Place held item in the inventory slot at index. // Swaps items if slot already has item. public void PlaceHeldItem(int index) // Stashes any held item in the first eligible slot. // Returns false if there is no place in the inventory for the Item. // Calls inputObject's OnTossHand(ref Slot hand) method before emptying hand if operation failed. public bool StashHeldItem() // Pick up a certain number of items from slot (x, y). // Places/ Swaps item if hand already has item. public void PickUpStack(int x, int y, int count) // Pick up a certain number of items from slot at index. // Places/ Swaps item if hand already has item. public void PickUpStack(int index, int count) // Places count items from hand into slot (x, y). // Swaps items if hand item is different from slot item. public void PlaceHeldStack(int x, int y, int count) // Places count items from hand into slot at index. // Swaps items if hand item is different from slot item. public void PlaceHeldStack(int index, int count) // Inserts item into slot (x, y) with a stack of count. // Unsafe! (Overrides any item already at x, y) public void InsertItem(Item item, int x, int y, int count = 1) // Places count items in the first available slot. // Adds to stack if possible. // Calls inputObject's OnTossItem(ref Item item) method before emptying hand if operation failed. public bool PlaceItem(Item item, int count = 1) // Place item as specified slot. // Calls inputObject's OnTossItem() method before emptying hand if operation failed. public bool PlaceItem(Item item, int x, int y, int count = 1)","title":"Methods"},{"location":"inventory/#inventorytexturerenderer","text":"","title":"Inventory.TextureRenderer"},{"location":"inventory/#description_1","text":"The TextureRenderer takes care of rendering the Inventory to a RenderTexture .","title":"Description"},{"location":"inventory/#static-properties_1","text":"// The RenderTexture with a rendering of the inventories being drawn. public static RenderTexture Texture { get; } //The UI object displaying the render texture on the canvas. public static RawImage UIObject { get;} // Pixels per unit. // Based on latest initiated inventory background sprite pixelsPerUnit. public static float PPU // Units per pixel. // 1 / PPU public static float UPP","title":"Static Properties"},{"location":"inventory/#properties_1","text":"public MeshData MeshData { get; } // Is this inventory the first inventory being rendered this frame? // Holds data of last rendered frame if no inventory has been rendered this frame. public bool IsFirstRenderer { get; } // The RectTransform of the InventoryImage being rendered to. public RectTransform RectTransform { get; } // The RectTransform of the Canvas parenting the image being rendered to. public RectTransform CanvasRectTransform { get; } // Bounds of the inventory in world space. public Bounds Bounds { get; }","title":"Properties"},{"location":"inventory/#methods_1","text":"// public void Update(Inventory inventory, InventoryImage image) [TODO] // Get position of the cursor relative to the render mesh. // (0, 0) is center of the inventory. public Vector2 GetHandPosition(Inventory inv, bool pixelSnap = false) // Get position of the inventory in world space. // (0, 0) is center of the render camera / canvas. public Vector3 GetInventoryPosition(Inventory inventory, bool pixelSnap = false)","title":"Methods"},{"location":"inventory/#inventorymeshdata","text":"","title":"Inventory.MeshData"},{"location":"inventory/#description_2","text":"The Inventory MeshData builds the inventory mesh to be rendered by the TextureRenderer.","title":"Description"},{"location":"inventory/#static-properties_2","text":"// Is the cursor hovering over any inventory meshes rendering to the screen? public static bool CursorIsOverMesh { get; }","title":"Static Properties"},{"location":"inventory/#properties_2","text":"// The Inventory mesh. // Shortcut for mf.sharedMesh. public Mesh Mesh { get; } // The MeshRenderer of the Inventory. public MeshRenderer mr { get; } // The MeshFilter of the Inventory. public MeshFilter mf { get;} // The object rendering the Inventory mesh. public GameObject MeshObject { get; } // Bounds of the inventory background in world space. public Bounds BackgroundBounds { get; }","title":"Properties"},{"location":"inventory/#constructors","text":"// Creates a new MeshData. public MeshData()","title":"Constructors"},{"location":"inventory/#methods_2","text":"// Update mesh data. Is called through Inventory.Draw(InventoryImage image) public void Update(Inventory inventory)","title":"Methods"},{"location":"inventory/#inventoryslotdata","text":"","title":"Inventory.SlotData"},{"location":"inventory/#description_3","text":"SlotData holds all the slots, and the items contained in them.","title":"Description"},{"location":"inventory/#static-properties_3","text":"// The hand, containing the held item. public static Slot hand { get; set; }","title":"Static Properties"},{"location":"inventory/#properties_3","text":"// The size of the inventory in slots. public Vector2 size { get; } // The number of slots horizontally. public int CountX // The number of slots vertically. public int CountY // The slot array of the inventory. public Slot[] slots","title":"Properties"},{"location":"inventory/#constructors_1","text":"// Creates a new SlotData. Size is slot count on x and y of inventory. public SlotData(Vector2 size)","title":"Constructors"},{"location":"inventory/#methods_3","text":"// Takes a slot (x, y) position and returns the array index. public int PositionToIndex(int x, int y, InventorySkin.SlotOrder order = SlotOrder.TopToBottom) // Takes a slot index in the array, and returns the (x ,y) position. public Vector2 IndexToPosition(int i, InventorySkin.SlotOrder order = SlotOrder.TopToBottom) // Clears highlighted slot, and reset ItemPosition and Item Scale for each slot. public void ResetSlotStates()","title":"Methods"},{"location":"inventory/#slot","text":"","title":"Slot"},{"location":"inventory/#description_4","text":"A slot containing an item and a stack count.","title":"Description"},{"location":"inventory/#properties_4","text":"// the ID of the item held in slot. public int heldItemID // Get the stack count of the item in slot. public Stack { get; } // Is the slot locked? public bool IsLocked { get; } // The State of the slot. Can be Open, Locked, or highlighted. public UseState State { get; } // The scale of the item sprite in slot. Update this value with SetItemScale(float scale). public ItemScale { get; } // Get the position of the item sprite in slot. public Vector2 ItemPosition { get; }","title":"Properties"},{"location":"inventory/#constructors_2","text":"// Create a new Slot. public Slot(int heldItem, int stack = 0, UseState state = UseState.Open)","title":"Constructors"},{"location":"inventory/#methods_4","text":"// Set the scale of the item sprite in slot. public void SetItemScale(float scale) // Set the position of the item sprite in slot. public void SetItemPosition(float x, float y) // Sets the item stack to value public void SetStack(int value) // Add or remove from item stack. Use AddToStackSmart to adhere to maxItemStack. public void AddToStack(int count) // Add or remove from item stack. // ref count is the amount of items to add, // and it returns the item count that potentially did not fit in slot. public void AddToStackSmart(ref int count, int maxItemStack) // Sets the UseState to Locked. public void Lock() // Sets the UseState to Open. public void Open() // Update slot state. public void UpdateState(UseState state) // Update heldItemID and stack of slot. public void Update(int heldItem, int stack)","title":"Methods"},{"location":"item-shelf/","text":"The Item Shelf Description The ItemShelf is a scriptableObject that holds data about all the items you set up, and the Inventory system unity package comes with a preconfigured ItemShelf containing a few items to help you get started. The ItemShelf has to be located in a /Resources/ folder. There can only be one ItemShelf per project. Static Properties public static int ItemCount; // Returns the current Item count in the ItemShelf. public static Item Random; // Returns a random item from the ItemShelf. Properties public List<Entry> entries // A list of all the Item entries in the ItemShelf. // use ItemShelf.GetInstance().entries; public string ResourcePath { private get; set; } // The resource path of the scriptableObject. // use ItemShelf.GetInstance().ResourcePath; Public Methods public void UpdateResourcePath(ItemShelf shelf) // Updates and saves the current Resource path of the ItemShelf scriptableObject. // his is called automatically when the scriptableObject path has changed. Static Methods public static ItemShelf GetInstance // Returns the static instance of the ItemShelf. // Loads the instance if it isn't loaded. public static Item GetItem(int index) // Returns Item at entries[index]. public static Item GetItem(string name) // Returns Item with name 'name'. public static Item GetItem<T>(int index) where T : Item // Returns Item at entries[index] as type T. Public static bool HasItem(int index) // Returns true if itemShelf contains item at index. Public static bool HasItem(string name) // Returns true if itemShelf contains item with name.","title":"Item Shelf"},{"location":"item-shelf/#the-item-shelf","text":"","title":"The Item Shelf"},{"location":"item-shelf/#description","text":"The ItemShelf is a scriptableObject that holds data about all the items you set up, and the Inventory system unity package comes with a preconfigured ItemShelf containing a few items to help you get started. The ItemShelf has to be located in a /Resources/ folder. There can only be one ItemShelf per project.","title":"Description"},{"location":"item-shelf/#static-properties","text":"public static int ItemCount; // Returns the current Item count in the ItemShelf. public static Item Random; // Returns a random item from the ItemShelf.","title":"Static Properties"},{"location":"item-shelf/#properties","text":"public List<Entry> entries // A list of all the Item entries in the ItemShelf. // use ItemShelf.GetInstance().entries; public string ResourcePath { private get; set; } // The resource path of the scriptableObject. // use ItemShelf.GetInstance().ResourcePath;","title":"Properties"},{"location":"item-shelf/#public-methods","text":"public void UpdateResourcePath(ItemShelf shelf) // Updates and saves the current Resource path of the ItemShelf scriptableObject. // his is called automatically when the scriptableObject path has changed.","title":"Public Methods"},{"location":"item-shelf/#static-methods","text":"public static ItemShelf GetInstance // Returns the static instance of the ItemShelf. // Loads the instance if it isn't loaded. public static Item GetItem(int index) // Returns Item at entries[index]. public static Item GetItem(string name) // Returns Item with name 'name'. public static Item GetItem<T>(int index) where T : Item // Returns Item at entries[index] as type T. Public static bool HasItem(int index) // Returns true if itemShelf contains item at index. Public static bool HasItem(string name) // Returns true if itemShelf contains item with name.","title":"Static Methods"}]}